#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>

#include "imgui.h"
#include "imgui_internal.h"
#include "imgui_docking_internal_types.h"

namespace py = pybind11;


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



void py_init_module_lg_examplelib(py::module& m)
{
    m.def("create_context",
          ImGui::CreateContext,
          py::arg("shared_font_atlas") = py::none(),
          pybind11::return_value_policy::reference);

    auto pyClassImVec2 =
        py::class_<ImVec2>
            (m, "ImVec2", "")
            .def_readwrite("x", &ImVec2::x, "")
            .def_readwrite("y", &ImVec2::y, "")
            .def(py::init<>())
            .def(py::init<float, float>(),
                 py::arg("_x"), py::arg("_y"))
            .def("__getitem__",
                 py::overload_cast<size_t>(&ImVec2::operator[]),
                 py::arg("idx"),
                 "(private API)\n\n We very rarely use this [] operator, so the assert overhead is fine.",
                 pybind11::return_value_policy::reference)
            .def("__getitem__",
                 py::overload_cast<size_t>(&ImVec2::operator[]),
                 py::arg("idx"),
                 "(private API)")
    ;

    auto pyClassImGuiContext =
        py::class_<ImGuiContext>
            (m, "Context", "")
            .def_readwrite("initialized", &ImGuiContext::Initialized, "")
            .def_readwrite("font_atlas_owned_by_context", &ImGuiContext::FontAtlasOwnedByContext, "IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.")
            .def_readwrite("io", &ImGuiContext::IO, "")
            .def_readwrite("platform_io", &ImGuiContext::PlatformIO, "")
            .def_readwrite("style", &ImGuiContext::Style, "")
            .def_readwrite("config_flags_curr_frame", &ImGuiContext::ConfigFlagsCurrFrame, "= g.IO.ConfigFlags at the time of NewFrame()")
            .def_readwrite("config_flags_last_frame", &ImGuiContext::ConfigFlagsLastFrame, "")
            .def_readwrite("font", &ImGuiContext::Font, "(Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()")
            .def_readwrite("font_size", &ImGuiContext::FontSize, "(Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.")
            .def_readwrite("font_base_size", &ImGuiContext::FontBaseSize, "(Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.")
            .def_readwrite("draw_list_shared_data", &ImGuiContext::DrawListSharedData, "")
            .def_readwrite("time", &ImGuiContext::Time, "")
            .def_readwrite("frame_count", &ImGuiContext::FrameCount, "")
            .def_readwrite("frame_count_ended", &ImGuiContext::FrameCountEnded, "")
            .def_readwrite("frame_count_platform_ended", &ImGuiContext::FrameCountPlatformEnded, "")
            .def_readwrite("frame_count_rendered", &ImGuiContext::FrameCountRendered, "")
            .def_readwrite("within_frame_scope", &ImGuiContext::WithinFrameScope, "Set by NewFrame(), cleared by EndFrame()")
            .def_readwrite("within_frame_scope_with_implicit_window", &ImGuiContext::WithinFrameScopeWithImplicitWindow, "Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed")
            .def_readwrite("within_end_child", &ImGuiContext::WithinEndChild, "Set within EndChild()")
            .def_readwrite("gc_compact_all", &ImGuiContext::GcCompactAll, "Request full GC")
            .def_readwrite("test_engine_hook_items", &ImGuiContext::TestEngineHookItems, "Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()")
            .def_readwrite("test_engine", &ImGuiContext::TestEngine, "Test engine user data")
            .def_readwrite("input_events_queue", &ImGuiContext::InputEventsQueue, "Input events which will be trickled/written into IO structure.")
            .def_readwrite("input_events_trail", &ImGuiContext::InputEventsTrail, "Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.")
            .def_readwrite("input_events_next_mouse_source", &ImGuiContext::InputEventsNextMouseSource, "")
            .def_readwrite("input_events_next_event_id", &ImGuiContext::InputEventsNextEventId, "")
            .def_readwrite("windows", &ImGuiContext::Windows, "Windows, sorted in display order, back to front")
            .def_readwrite("windows_focus_order", &ImGuiContext::WindowsFocusOrder, "Root windows, sorted in focus order, back to front.")
            .def_readwrite("windows_temp_sort_buffer", &ImGuiContext::WindowsTempSortBuffer, "Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child")
            .def_readwrite("current_window_stack", &ImGuiContext::CurrentWindowStack, "")
            .def_readwrite("windows_by_id", &ImGuiContext::WindowsById, "Map window's ImGuiID to ImGuiWindow*")
            .def_readwrite("windows_active_count", &ImGuiContext::WindowsActiveCount, "Number of unique windows submitted by frame")
            .def_readwrite("windows_hover_padding", &ImGuiContext::WindowsHoverPadding, "Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING)")
            .def_readwrite("debug_break_in_window", &ImGuiContext::DebugBreakInWindow, "Set to break in Begin() call.")
            .def_readwrite("current_window", &ImGuiContext::CurrentWindow, "Window being drawn into")
            .def_readwrite("hovered_window", &ImGuiContext::HoveredWindow, "Window the mouse is hovering. Will typically catch mouse inputs.")
            .def_readwrite("hovered_window_under_moving_window", &ImGuiContext::HoveredWindowUnderMovingWindow, "Hovered window ignoring MovingWindow. Only set if MovingWindow is set.")
            .def_readwrite("moving_window", &ImGuiContext::MovingWindow, "Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindowDockTree.")
            .def_readwrite("wheeling_window", &ImGuiContext::WheelingWindow, "Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.")
            .def_readwrite("wheeling_window_ref_mouse_pos", &ImGuiContext::WheelingWindowRefMousePos, "")
            .def_readwrite("wheeling_window_start_frame", &ImGuiContext::WheelingWindowStartFrame, "This may be set one frame before WheelingWindow is != None")
            .def_readwrite("wheeling_window_scrolled_frame", &ImGuiContext::WheelingWindowScrolledFrame, "")
            .def_readwrite("wheeling_window_release_timer", &ImGuiContext::WheelingWindowReleaseTimer, "")
            .def_readwrite("wheeling_window_wheel_remainder", &ImGuiContext::WheelingWindowWheelRemainder, "")
            .def_readwrite("wheeling_axis_avg", &ImGuiContext::WheelingAxisAvg, "")
            .def_readwrite("debug_hook_id_info", &ImGuiContext::DebugHookIdInfo, "Will call core hooks: DebugHookIdInfo() from GetID functions, used by ID Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]")
            .def_readwrite("hovered_id", &ImGuiContext::HoveredId, "Hovered widget, filled during the frame")
            .def_readwrite("hovered_id_previous_frame", &ImGuiContext::HoveredIdPreviousFrame, "")
            .def_readwrite("hovered_id_allow_overlap", &ImGuiContext::HoveredIdAllowOverlap, "")
            .def_readwrite("hovered_id_disabled", &ImGuiContext::HoveredIdDisabled, "At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be True even if HoveredId == 0.")
            .def_readwrite("hovered_id_timer", &ImGuiContext::HoveredIdTimer, "Measure contiguous hovering time")
            .def_readwrite("hovered_id_not_active_timer", &ImGuiContext::HoveredIdNotActiveTimer, "Measure contiguous hovering time where the item has not been active")
            .def_readwrite("active_id", &ImGuiContext::ActiveId, "Active widget")
            .def_readwrite("active_id_is_alive", &ImGuiContext::ActiveIdIsAlive, "Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)")
            .def_readwrite("active_id_timer", &ImGuiContext::ActiveIdTimer, "")
            .def_readwrite("active_id_is_just_activated", &ImGuiContext::ActiveIdIsJustActivated, "Set at the time of activation for one frame")
            .def_readwrite("active_id_allow_overlap", &ImGuiContext::ActiveIdAllowOverlap, "Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)")
            .def_readwrite("active_id_no_clear_on_focus_loss", &ImGuiContext::ActiveIdNoClearOnFocusLoss, "Disable losing active id if the active id window gets unfocused.")
            .def_readwrite("active_id_has_been_pressed_before", &ImGuiContext::ActiveIdHasBeenPressedBefore, "Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.")
            .def_readwrite("active_id_has_been_edited_before", &ImGuiContext::ActiveIdHasBeenEditedBefore, "Was the value associated to the widget Edited over the course of the Active state.")
            .def_readwrite("active_id_has_been_edited_this_frame", &ImGuiContext::ActiveIdHasBeenEditedThisFrame, "")
            .def_readwrite("active_id_click_offset", &ImGuiContext::ActiveIdClickOffset, "Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)")
            .def_readwrite("active_id_window", &ImGuiContext::ActiveIdWindow, "")
            .def_readwrite("active_id_source", &ImGuiContext::ActiveIdSource, "Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad")
            .def_readwrite("active_id_mouse_button", &ImGuiContext::ActiveIdMouseButton, "")
            .def_readwrite("active_id_previous_frame", &ImGuiContext::ActiveIdPreviousFrame, "")
            .def_readwrite("active_id_previous_frame_is_alive", &ImGuiContext::ActiveIdPreviousFrameIsAlive, "")
            .def_readwrite("active_id_previous_frame_has_been_edited_before", &ImGuiContext::ActiveIdPreviousFrameHasBeenEditedBefore, "")
            .def_readwrite("active_id_previous_frame_window", &ImGuiContext::ActiveIdPreviousFrameWindow, "")
            .def_readwrite("last_active_id", &ImGuiContext::LastActiveId, "Store the last non-zero ActiveId, useful for animation.")
            .def_readwrite("last_active_id_timer", &ImGuiContext::LastActiveIdTimer, "Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.")
            .def_readwrite("last_key_mods_change_time", &ImGuiContext::LastKeyModsChangeTime, "Record the last time key mods changed (affect repeat delay when using shortcut logic)")
            .def_readwrite("last_key_mods_change_from_none_time", &ImGuiContext::LastKeyModsChangeFromNoneTime, "Record the last time key mods changed away from being 0 (affect repeat delay when using shortcut logic)")
            .def_readwrite("last_keyboard_key_press_time", &ImGuiContext::LastKeyboardKeyPressTime, "Record the last time a keyboard key (ignore mouse/gamepad ones) was pressed.")
            .def_readwrite("keys_routing_table", &ImGuiContext::KeysRoutingTable, "")
            .def_readwrite("active_id_using_nav_dir_mask", &ImGuiContext::ActiveIdUsingNavDirMask, "Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)")
            .def_readwrite("active_id_using_all_keyboard_keys", &ImGuiContext::ActiveIdUsingAllKeyboardKeys, "Active widget will want to read all keyboard keys inputs. (FIXME: This is a shortcut for not taking ownership of 100+ keys but perhaps best to not have the inconsistency)")
            .def_readwrite("debug_break_in_shortcut_routing", &ImGuiContext::DebugBreakInShortcutRouting, "")
            .def_readwrite("current_focus_scope_id", &ImGuiContext::CurrentFocusScopeId, "== g.FocusScopeStack.back()")
            .def_readwrite("current_item_flags", &ImGuiContext::CurrentItemFlags, "== g.ItemFlagsStack.back()")
            .def_readwrite("debug_locate_id", &ImGuiContext::DebugLocateId, "Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location")
            .def_readwrite("next_item_data", &ImGuiContext::NextItemData, "Storage for SetNextItem** functions")
            .def_readwrite("last_item_data", &ImGuiContext::LastItemData, "Storage for last submitted item (setup by ItemAdd)")
            .def_readwrite("next_window_data", &ImGuiContext::NextWindowData, "Storage for SetNextWindow** functions")
            .def_readwrite("debug_show_group_rects", &ImGuiContext::DebugShowGroupRects, "")
            .def_readwrite("debug_flash_style_color_idx", &ImGuiContext::DebugFlashStyleColorIdx, "(Keep close to ColorStack to share cache line)")
            .def_readwrite("color_stack", &ImGuiContext::ColorStack, "Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()")
            .def_readwrite("style_var_stack", &ImGuiContext::StyleVarStack, "Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()")
            .def_readwrite("font_stack", &ImGuiContext::FontStack, "Stack for PushFont()/PopFont() - inherited by Begin()")
            .def_readwrite("focus_scope_stack", &ImGuiContext::FocusScopeStack, "Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()")
            .def_readwrite("item_flags_stack", &ImGuiContext::ItemFlagsStack, "Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()")
            .def_readwrite("group_stack", &ImGuiContext::GroupStack, "Stack for BeginGroup()/EndGroup() - not inherited by Begin()")
            .def_readwrite("open_popup_stack", &ImGuiContext::OpenPopupStack, "Which popups are open (persistent)")
            .def_readwrite("begin_popup_stack", &ImGuiContext::BeginPopupStack, "Which level of BeginPopup() we are in (reset every frame)")
            .def_readwrite("nav_tree_node_stack", &ImGuiContext::NavTreeNodeStack, "Stack for TreeNode() when a NavLeft requested is emitted.")
            .def_readwrite("begin_menu_count", &ImGuiContext::BeginMenuCount, "")
            .def_readwrite("viewports", &ImGuiContext::Viewports, "Active viewports (always 1+, and generally 1 unless multi-viewports are enabled). Each viewports hold their copy of ImDrawData.")
            .def_readwrite("current_dpi_scale", &ImGuiContext::CurrentDpiScale, "== CurrentViewport->DpiScale")
            .def_readwrite("current_viewport", &ImGuiContext::CurrentViewport, "We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()")
            .def_readwrite("mouse_viewport", &ImGuiContext::MouseViewport, "")
            .def_readwrite("mouse_last_hovered_viewport", &ImGuiContext::MouseLastHoveredViewport, "Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.")
            .def_readwrite("platform_last_focused_viewport_id", &ImGuiContext::PlatformLastFocusedViewportId, "")
            .def_readwrite("fallback_monitor", &ImGuiContext::FallbackMonitor, "Virtual monitor used as fallback if backend doesn't provide monitor information.")
            .def_readwrite("viewport_created_count", &ImGuiContext::ViewportCreatedCount, "Unique sequential creation counter (mostly for testing/debugging)")
            .def_readwrite("platform_windows_created_count", &ImGuiContext::PlatformWindowsCreatedCount, "Unique sequential creation counter (mostly for testing/debugging)")
            .def_readwrite("viewport_focused_stamp_count", &ImGuiContext::ViewportFocusedStampCount, "Every time the front-most window changes, we stamp its viewport with an incrementing counter")
            .def_readwrite("nav_window", &ImGuiContext::NavWindow, "Focused window for navigation. Could be called 'FocusedWindow'")
            .def_readwrite("nav_id", &ImGuiContext::NavId, "Focused item for navigation")
            .def_readwrite("nav_focus_scope_id", &ImGuiContext::NavFocusScopeId, "Identify a selection scope (selection code often wants to \"clear other items\" when landing on an item of the selection set)")
            .def_readwrite("nav_activate_id", &ImGuiContext::NavActivateId, "~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()")
            .def_readwrite("nav_activate_down_id", &ImGuiContext::NavActivateDownId, "~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0")
            .def_readwrite("nav_activate_pressed_id", &ImGuiContext::NavActivatePressedId, "~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)")
            .def_readwrite("nav_activate_flags", &ImGuiContext::NavActivateFlags, "")
            .def_readwrite("nav_just_moved_to_id", &ImGuiContext::NavJustMovedToId, "Just navigated to this id (result of a successfully MoveRequest).")
            .def_readwrite("nav_just_moved_to_focus_scope_id", &ImGuiContext::NavJustMovedToFocusScopeId, "Just navigated to this focus scope id (result of a successfully MoveRequest).")
            .def_readwrite("nav_just_moved_to_key_mods", &ImGuiContext::NavJustMovedToKeyMods, "")
            .def_readwrite("nav_next_activate_id", &ImGuiContext::NavNextActivateId, "Set by ActivateItem(), queued until next frame.")
            .def_readwrite("nav_next_activate_flags", &ImGuiContext::NavNextActivateFlags, "")
            .def_readwrite("nav_input_source", &ImGuiContext::NavInputSource, "Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse")
            .def_readwrite("nav_layer", &ImGuiContext::NavLayer, "Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.")
            .def_readwrite("nav_last_valid_selection_user_data", &ImGuiContext::NavLastValidSelectionUserData, "Last valid data passed to SetNextItemSelectionUser(), or -1. For current window. Not reset when focusing an item that doesn't have selection data.")
            .def_readwrite("nav_id_is_alive", &ImGuiContext::NavIdIsAlive, "Nav widget has been seen this frame ~~ NavRectRel is valid")
            .def_readwrite("nav_mouse_pos_dirty", &ImGuiContext::NavMousePosDirty, "When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)")
            .def_readwrite("nav_disable_highlight", &ImGuiContext::NavDisableHighlight, "When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)")
            .def_readwrite("nav_disable_mouse_hover", &ImGuiContext::NavDisableMouseHover, "When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.")
            .def_readwrite("nav_any_request", &ImGuiContext::NavAnyRequest, "~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()")
            .def_readwrite("nav_init_request", &ImGuiContext::NavInitRequest, "Init request for appearing window to select first item")
            .def_readwrite("nav_init_request_from_move", &ImGuiContext::NavInitRequestFromMove, "")
            .def_readwrite("nav_init_result", &ImGuiContext::NavInitResult, "Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)")
            .def_readwrite("nav_move_submitted", &ImGuiContext::NavMoveSubmitted, "Move request submitted, will process result on next NewFrame()")
            .def_readwrite("nav_move_scoring_items", &ImGuiContext::NavMoveScoringItems, "Move request submitted, still scoring incoming items")
            .def_readwrite("nav_move_forward_to_next_frame", &ImGuiContext::NavMoveForwardToNextFrame, "")
            .def_readwrite("nav_move_flags", &ImGuiContext::NavMoveFlags, "")
            .def_readwrite("nav_move_scroll_flags", &ImGuiContext::NavMoveScrollFlags, "")
            .def_readwrite("nav_move_key_mods", &ImGuiContext::NavMoveKeyMods, "")
            .def_readwrite("nav_move_dir", &ImGuiContext::NavMoveDir, "Direction of the move request (left/right/up/down)")
            .def_readwrite("nav_move_dir_for_debug", &ImGuiContext::NavMoveDirForDebug, "")
            .def_readwrite("nav_move_clip_dir", &ImGuiContext::NavMoveClipDir, "FIXME-NAV: Describe the purpose of this better. Might want to rename?")
            .def_readwrite("nav_scoring_rect", &ImGuiContext::NavScoringRect, "Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.")
            .def_readwrite("nav_scoring_no_clip_rect", &ImGuiContext::NavScoringNoClipRect, "Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted")
            .def_readwrite("nav_scoring_debug_count", &ImGuiContext::NavScoringDebugCount, "Metrics for debugging")
            .def_readwrite("nav_tabbing_dir", &ImGuiContext::NavTabbingDir, "Generally -1 or +1, 0 when tabbing without a nav id")
            .def_readwrite("nav_tabbing_counter", &ImGuiContext::NavTabbingCounter, ">0 when counting items for tabbing")
            .def_readwrite("nav_move_result_local", &ImGuiContext::NavMoveResultLocal, "Best move request candidate within NavWindow")
            .def_readwrite("nav_move_result_local_visible", &ImGuiContext::NavMoveResultLocalVisible, "Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)")
            .def_readwrite("nav_move_result_other", &ImGuiContext::NavMoveResultOther, "Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)")
            .def_readwrite("nav_tabbing_result_first", &ImGuiContext::NavTabbingResultFirst, "First tabbing request candidate within NavWindow and flattened hierarchy")
            .def_readwrite("config_nav_windowing_key_next", &ImGuiContext::ConfigNavWindowingKeyNext, "= ImGuiMod_Ctrl | ImGuiKey_Tab, for reconfiguration (see #4828)")
            .def_readwrite("config_nav_windowing_key_prev", &ImGuiContext::ConfigNavWindowingKeyPrev, "= ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab")
            .def_readwrite("nav_windowing_target", &ImGuiContext::NavWindowingTarget, "Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!")
            .def_readwrite("nav_windowing_target_anim", &ImGuiContext::NavWindowingTargetAnim, "Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0, so the fade-out can stay on it.")
            .def_readwrite("nav_windowing_list_window", &ImGuiContext::NavWindowingListWindow, "Internal window actually listing the CTRL+Tab contents")
            .def_readwrite("nav_windowing_timer", &ImGuiContext::NavWindowingTimer, "")
            .def_readwrite("nav_windowing_highlight_alpha", &ImGuiContext::NavWindowingHighlightAlpha, "")
            .def_readwrite("nav_windowing_toggle_layer", &ImGuiContext::NavWindowingToggleLayer, "")
            .def_readwrite("nav_windowing_accum_delta_pos", &ImGuiContext::NavWindowingAccumDeltaPos, "")
            .def_readwrite("nav_windowing_accum_delta_size", &ImGuiContext::NavWindowingAccumDeltaSize, "")
            .def_readwrite("dim_bg_ratio", &ImGuiContext::DimBgRatio, "0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)")
            .def_readwrite("drag_drop_active", &ImGuiContext::DragDropActive, "")
            .def_readwrite("drag_drop_within_source", &ImGuiContext::DragDropWithinSource, "Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.")
            .def_readwrite("drag_drop_within_target", &ImGuiContext::DragDropWithinTarget, "Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.")
            .def_readwrite("drag_drop_source_flags", &ImGuiContext::DragDropSourceFlags, "")
            .def_readwrite("drag_drop_source_frame_count", &ImGuiContext::DragDropSourceFrameCount, "")
            .def_readwrite("drag_drop_mouse_button", &ImGuiContext::DragDropMouseButton, "")
            .def_readwrite("drag_drop_payload", &ImGuiContext::DragDropPayload, "")
            .def_readwrite("drag_drop_target_rect", &ImGuiContext::DragDropTargetRect, "Store rectangle of current target candidate (we favor small targets when overlapping)")
            .def_readwrite("drag_drop_target_clip_rect", &ImGuiContext::DragDropTargetClipRect, "Store ClipRect at the time of item's drawing")
            .def_readwrite("drag_drop_target_id", &ImGuiContext::DragDropTargetId, "")
            .def_readwrite("drag_drop_accept_flags", &ImGuiContext::DragDropAcceptFlags, "")
            .def_readwrite("drag_drop_accept_id_curr_rect_surface", &ImGuiContext::DragDropAcceptIdCurrRectSurface, "Target item surface (we resolve overlapping targets by prioritizing the smaller surface)")
            .def_readwrite("drag_drop_accept_id_curr", &ImGuiContext::DragDropAcceptIdCurr, "Target item id (set at the time of accepting the payload)")
            .def_readwrite("drag_drop_accept_id_prev", &ImGuiContext::DragDropAcceptIdPrev, "Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)")
            .def_readwrite("drag_drop_accept_frame_count", &ImGuiContext::DragDropAcceptFrameCount, "Last time a target expressed a desire to accept the source")
            .def_readwrite("drag_drop_hold_just_pressed_id", &ImGuiContext::DragDropHoldJustPressedId, "Set when holding a payload just made ButtonBehavior() return a press.")
            .def_readwrite("drag_drop_payload_buf_heap", &ImGuiContext::DragDropPayloadBufHeap, "We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size")
            .def_readwrite("clipper_temp_data_stacked", &ImGuiContext::ClipperTempDataStacked, "")
            .def_readwrite("clipper_temp_data", &ImGuiContext::ClipperTempData, "")
            .def_readwrite("current_table", &ImGuiContext::CurrentTable, "")
            .def_readwrite("debug_break_in_table", &ImGuiContext::DebugBreakInTable, "Set to break in BeginTable() call.")
            .def_readwrite("tables_temp_data_stacked", &ImGuiContext::TablesTempDataStacked, "Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)")
            .def_readwrite("tables_temp_data", &ImGuiContext::TablesTempData, "Temporary table data (buffers reused/shared across instances, support nesting)")
            .def_readwrite("tables_last_time_active", &ImGuiContext::TablesLastTimeActive, "Last used timestamp of each tables (SOA, for efficient GC)")
            .def_readwrite("draw_channels_temp_merge_buffer", &ImGuiContext::DrawChannelsTempMergeBuffer, "")
            .def_readwrite("current_tab_bar", &ImGuiContext::CurrentTabBar, "")
            .def_readwrite("current_tab_bar_stack", &ImGuiContext::CurrentTabBarStack, "")
            .def_readwrite("shrink_width_buffer", &ImGuiContext::ShrinkWidthBuffer, "")
            .def_readwrite("hover_item_delay_id", &ImGuiContext::HoverItemDelayId, "")
            .def_readwrite("hover_item_delay_id_previous_frame", &ImGuiContext::HoverItemDelayIdPreviousFrame, "")
            .def_readwrite("hover_item_delay_timer", &ImGuiContext::HoverItemDelayTimer, "Currently used by IsItemHovered()")
            .def_readwrite("hover_item_delay_clear_timer", &ImGuiContext::HoverItemDelayClearTimer, "Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.")
            .def_readwrite("hover_item_unlocked_stationary_id", &ImGuiContext::HoverItemUnlockedStationaryId, "Mouse has once been stationary on this item. Only reset after departing the item.")
            .def_readwrite("hover_window_unlocked_stationary_id", &ImGuiContext::HoverWindowUnlockedStationaryId, "Mouse has once been stationary on this window. Only reset after departing the window.")
            .def_readwrite("mouse_cursor", &ImGuiContext::MouseCursor, "")
            .def_readwrite("mouse_stationary_timer", &ImGuiContext::MouseStationaryTimer, "Time the mouse has been stationary (with some loose heuristic)")
            .def_readwrite("mouse_last_valid_pos", &ImGuiContext::MouseLastValidPos, "")
            .def_readwrite("input_text_state", &ImGuiContext::InputTextState, "")
            .def_readwrite("input_text_deactivated_state", &ImGuiContext::InputTextDeactivatedState, "")
            .def_readwrite("input_text_password_font", &ImGuiContext::InputTextPasswordFont, "")
            .def_readwrite("temp_input_id", &ImGuiContext::TempInputId, "Temporary text input when CTRL+clicking on a slider, etc.")
            .def_readwrite("color_edit_options", &ImGuiContext::ColorEditOptions, "Store user options for color edit widgets")
            .def_readwrite("color_edit_current_id", &ImGuiContext::ColorEditCurrentID, "Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).")
            .def_readwrite("color_edit_saved_id", &ImGuiContext::ColorEditSavedID, "ID we are saving/restoring HS for")
            .def_readwrite("color_edit_saved_hue", &ImGuiContext::ColorEditSavedHue, "Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips")
            .def_readwrite("color_edit_saved_sat", &ImGuiContext::ColorEditSavedSat, "Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips")
            .def_readwrite("color_edit_saved_color", &ImGuiContext::ColorEditSavedColor, "RGB value with alpha set to 0.")
            .def_readwrite("color_picker_ref", &ImGuiContext::ColorPickerRef, "Initial/reference color at the time of opening the color picker.")
            .def_readwrite("combo_preview_data", &ImGuiContext::ComboPreviewData, "")
            .def_readwrite("window_resize_border_expected_rect", &ImGuiContext::WindowResizeBorderExpectedRect, "Expected border rect, switch to relative edit if moving")
            .def_readwrite("window_resize_relative_mode", &ImGuiContext::WindowResizeRelativeMode, "")
            .def_readwrite("slider_grab_click_offset", &ImGuiContext::SliderGrabClickOffset, "")
            .def_readwrite("slider_current_accum", &ImGuiContext::SliderCurrentAccum, "Accumulated slider delta when using navigation controls.")
            .def_readwrite("slider_current_accum_dirty", &ImGuiContext::SliderCurrentAccumDirty, "Has the accumulated slider delta changed since last time we tried to apply it?")
            .def_readwrite("drag_current_accum_dirty", &ImGuiContext::DragCurrentAccumDirty, "")
            .def_readwrite("drag_current_accum", &ImGuiContext::DragCurrentAccum, "Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings")
            .def_readwrite("drag_speed_default_ratio", &ImGuiContext::DragSpeedDefaultRatio, "If speed == 0.0, uses (max-min) * DragSpeedDefaultRatio")
            .def_readwrite("scrollbar_click_delta_to_grab_center", &ImGuiContext::ScrollbarClickDeltaToGrabCenter, "Distance between mouse and center of grab box, normalized in parent space. Use storage?")
            .def_readwrite("disabled_alpha_backup", &ImGuiContext::DisabledAlphaBackup, "Backup for style.Alpha for BeginDisabled()")
            .def_readwrite("disabled_stack_size", &ImGuiContext::DisabledStackSize, "")
            .def_readwrite("lock_mark_edited", &ImGuiContext::LockMarkEdited, "")
            .def_readwrite("tooltip_override_count", &ImGuiContext::TooltipOverrideCount, "")
            .def_readwrite("clipboard_handler_data", &ImGuiContext::ClipboardHandlerData, "If no custom clipboard handler is defined")
            .def_readwrite("menus_id_submitted_this_frame", &ImGuiContext::MenusIdSubmittedThisFrame, "A list of menu IDs that were rendered at least once")
            .def_readwrite("typing_select_state", &ImGuiContext::TypingSelectState, "State for GetTypingSelectRequest()")
            .def_readwrite("platform_ime_data", &ImGuiContext::PlatformImeData, "Data updated by current frame")
            .def_readwrite("platform_ime_data_prev", &ImGuiContext::PlatformImeDataPrev, "Previous frame data (when changing we will call io.SetPlatformImeDataFn")
            .def_readwrite("platform_ime_viewport", &ImGuiContext::PlatformImeViewport, "")
            .def_readwrite("dock_context", &ImGuiContext::DockContext, " Extensions\n FIXME: We could provide an API to register one slot in an array held in ImGuiContext?")
            .def_readwrite("settings_loaded", &ImGuiContext::SettingsLoaded, "")
            .def_readwrite("settings_dirty_timer", &ImGuiContext::SettingsDirtyTimer, "Save .ini Settings to memory when time reaches zero")
            .def_readwrite("settings_ini_data", &ImGuiContext::SettingsIniData, "In memory .ini settings")
            .def_readwrite("settings_handlers", &ImGuiContext::SettingsHandlers, "List of .ini settings handlers")
            .def_readwrite("hook_id_next", &ImGuiContext::HookIdNext, "Next available HookId")
            .def_readwrite("log_enabled", &ImGuiContext::LogEnabled, "Currently capturing")
            .def_readwrite("log_type", &ImGuiContext::LogType, "Capture target")
            .def_readwrite("log_file", &ImGuiContext::LogFile, "If != None log to stdout/ file")
            .def_readwrite("log_buffer", &ImGuiContext::LogBuffer, "Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.")
            .def_readonly("log_next_prefix", &ImGuiContext::LogNextPrefix, "")
            .def_readonly("log_next_suffix", &ImGuiContext::LogNextSuffix, "")
            .def_readwrite("log_line_pos_y", &ImGuiContext::LogLinePosY, "")
            .def_readwrite("log_line_first_item", &ImGuiContext::LogLineFirstItem, "")
            .def_readwrite("log_depth_ref", &ImGuiContext::LogDepthRef, "")
            .def_readwrite("log_depth_to_expand", &ImGuiContext::LogDepthToExpand, "")
            .def_readwrite("log_depth_to_expand_default", &ImGuiContext::LogDepthToExpandDefault, "Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.")
            .def_readwrite("debug_log_flags", &ImGuiContext::DebugLogFlags, "")
            .def_readwrite("debug_log_buf", &ImGuiContext::DebugLogBuf, "")
            .def_readwrite("debug_log_index", &ImGuiContext::DebugLogIndex, "")
            .def_readwrite("debug_log_auto_disable_flags", &ImGuiContext::DebugLogAutoDisableFlags, "")
            .def_readwrite("debug_log_auto_disable_frames", &ImGuiContext::DebugLogAutoDisableFrames, "")
            .def_readwrite("debug_locate_frames", &ImGuiContext::DebugLocateFrames, "For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.")
            .def_readwrite("debug_break_in_locate_id", &ImGuiContext::DebugBreakInLocateId, "Debug break in ItemAdd() call for g.DebugLocateId.")
            .def_readwrite("debug_break_key_chord", &ImGuiContext::DebugBreakKeyChord, "= ImGuiKey_Pause")
            .def_readwrite("debug_begin_return_value_cull_depth", &ImGuiContext::DebugBeginReturnValueCullDepth, "Cycle between 0..9 then wrap around.")
            .def_readwrite("debug_item_picker_active", &ImGuiContext::DebugItemPickerActive, "Item picker is active (started with DebugStartItemPicker())")
            .def_readwrite("debug_item_picker_mouse_button", &ImGuiContext::DebugItemPickerMouseButton, "")
            .def_readwrite("debug_item_picker_break_id", &ImGuiContext::DebugItemPickerBreakId, "Will call IM_DEBUG_BREAK() when encountering this ID")
            .def_readwrite("debug_flash_style_color_time", &ImGuiContext::DebugFlashStyleColorTime, "")
            .def_readwrite("debug_flash_style_color_backup", &ImGuiContext::DebugFlashStyleColorBackup, "")
            .def_readwrite("debug_metrics_config", &ImGuiContext::DebugMetricsConfig, "")
            .def_readwrite("debug_id_stack_tool", &ImGuiContext::DebugIDStackTool, "")
            .def_readwrite("debug_alloc_info", &ImGuiContext::DebugAllocInfo, "")
            .def_readwrite("debug_hovered_dock_node", &ImGuiContext::DebugHoveredDockNode, "Hovered dock node.")
            .def_property("framerate_sec_per_frame",
                          [](ImGuiContext &self) -> pybind11::array
                          {
                              auto dtype = pybind11::dtype(pybind11::format_descriptor<float>::format());
                              auto base = pybind11::array(dtype, {60}, {sizeof(float)});
                              return pybind11::array(dtype, {60}, {sizeof(float)}, self.FramerateSecPerFrame, base);
                          }, [](ImGuiContext& self) {},
                          "Calculate estimate of framerate for user over the last 60 frames..")
            .def_readwrite("framerate_sec_per_frame_idx", &ImGuiContext::FramerateSecPerFrameIdx, "")
            .def_readwrite("framerate_sec_per_frame_count", &ImGuiContext::FramerateSecPerFrameCount, "")
            .def_readwrite("framerate_sec_per_frame_accum", &ImGuiContext::FramerateSecPerFrameAccum, "")
            .def_readwrite("want_capture_mouse_next_frame", &ImGuiContext::WantCaptureMouseNextFrame, "Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.")
            .def_readwrite("want_capture_keyboard_next_frame", &ImGuiContext::WantCaptureKeyboardNextFrame, "\"")
            .def_readwrite("want_text_input_next_frame", &ImGuiContext::WantTextInputNextFrame, "")
            .def_readwrite("temp_buffer", &ImGuiContext::TempBuffer, "Temporary text buffer")
            .def(py::init<ImFontAtlas *>(),
                 py::arg("shared_font_atlas"))
    ;


    auto pyClassImFontConfig =
        py::class_<ImFontConfig>
            (m, "ImFontConfig", "")
            .def_readwrite("font_data", &ImFontConfig::FontData, "// TTF/OTF data")
            .def_readwrite("font_data_size", &ImFontConfig::FontDataSize, "// TTF/OTF data size")
            .def_readwrite("font_data_owned_by_atlas", &ImFontConfig::FontDataOwnedByAtlas, "True     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).")
            .def_readwrite("font_no", &ImFontConfig::FontNo, "0        // Index of font within TTF/OTF file")
            .def_readwrite("size_pixels", &ImFontConfig::SizePixels, "// Size in pixels for rasterizer (more or less maps to the resulting font height).")
            .def_readwrite("oversample_h", &ImFontConfig::OversampleH, "2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.")
            .def_readwrite("oversample_v", &ImFontConfig::OversampleV, "1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.")
            .def_readwrite("pixel_snap_h", &ImFontConfig::PixelSnapH, "False    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.")
            .def_readwrite("glyph_extra_spacing", &ImFontConfig::GlyphExtraSpacing, "0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.")
            .def_readwrite("glyph_offset", &ImFontConfig::GlyphOffset, "0, 0     // Offset all glyphs from this font input.")
            .def_readwrite("glyph_min_advance_x", &ImFontConfig::GlyphMinAdvanceX, "0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font")
            .def_readwrite("glyph_max_advance_x", &ImFontConfig::GlyphMaxAdvanceX, "FLT_MAX  // Maximum AdvanceX for glyphs")
            .def_readwrite("merge_mode", &ImFontConfig::MergeMode, "False    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.")
            .def_readwrite("font_builder_flags", &ImFontConfig::FontBuilderFlags, "0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.")
            .def_readwrite("rasterizer_multiply", &ImFontConfig::RasterizerMultiply, "1.0     // Linearly brighten (>1.0) or darken (<1.0) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.")
            .def_readwrite("rasterizer_density", &ImFontConfig::RasterizerDensity, "1.0     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.")
            .def_readwrite("ellipsis_char", &ImFontConfig::EllipsisChar, "-1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.")
            .def_readwrite("dst_font", &ImFontConfig::DstFont, "")
            .def(py::init<>())
    ;


    auto pyClassImFontGlyph =
        py::class_<ImFontGlyph>
            (m, "ImFontGlyph", " Hold rendering data for one glyph.\n (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)")
            .def(py::init<>([](
                     float AdvanceX = float(), float X0 = float(), float Y0 = float(), float X1 = float(), float Y1 = float(), float U0 = float(), float V0 = float(), float U1 = float(), float V1 = float())
                            {
                                auto r = std::make_unique<ImFontGlyph>();
                                r->AdvanceX = AdvanceX;
                                r->X0 = X0;
                                r->Y0 = Y0;
                                r->X1 = X1;
                                r->Y1 = Y1;
                                r->U0 = U0;
                                r->V0 = V0;
                                r->U1 = U1;
                                r->V1 = V1;
                                return r;
                            })
                , py::arg("advance_x") = float(), py::arg("x0") = float(), py::arg("y0") = float(), py::arg("x1") = float(), py::arg("y1") = float(), py::arg("u0") = float(), py::arg("v0") = float(), py::arg("u1") = float(), py::arg("v1") = float()
            )
            .def_readwrite("advance_x", &ImFontGlyph::AdvanceX, "Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)")
            .def_readwrite("x0", &ImFontGlyph::X0, "Glyph corners")
            .def_readwrite("y0", &ImFontGlyph::Y0, "Glyph corners")
            .def_readwrite("x1", &ImFontGlyph::X1, "Glyph corners")
            .def_readwrite("y1", &ImFontGlyph::Y1, "Glyph corners")
            .def_readwrite("u0", &ImFontGlyph::U0, "Texture coordinates")
            .def_readwrite("v0", &ImFontGlyph::V0, "Texture coordinates")
            .def_readwrite("u1", &ImFontGlyph::U1, "Texture coordinates")
            .def_readwrite("v1", &ImFontGlyph::V1, "Texture coordinates")
    ;


    auto pyClassImFontGlyphRangesBuilder =
        py::class_<ImFontGlyphRangesBuilder>
            (m, "ImFontGlyphRangesBuilder", " Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().\n This is essentially a tightly packed of vector of 64k booleans = 8KB storage.")
            .def_readwrite("used_chars", &ImFontGlyphRangesBuilder::UsedChars, "Store 1-bit per Unicode code point (0=unused, 1=used)")
            .def(py::init<>())
            .def("clear",
                 &ImFontGlyphRangesBuilder::Clear, "(private API)")
            .def("get_bit",
                 &ImFontGlyphRangesBuilder::GetBit,
                 py::arg("n"),
                 "(private API)\n\n Get bit n in the array")
            .def("set_bit",
                 &ImFontGlyphRangesBuilder::SetBit,
                 py::arg("n"),
                 "(private API)\n\n Set bit n in the array")
            .def("add_char",
                 &ImFontGlyphRangesBuilder::AddChar,
                 py::arg("c"),
                 "(private API)\n\n Add character")
            .def("add_text",
                 &ImFontGlyphRangesBuilder::AddText,
                 py::arg("text"), py::arg("text_end") = py::none(),
                 "Add string (each character of the UTF-8 string are added)")
            .def("build_ranges",
                 &ImFontGlyphRangesBuilder::BuildRanges,
                 py::arg("out_ranges"),
                 "Output new ranges")
    ;


    auto pyClassImFontAtlasCustomRect =
        py::class_<ImFontAtlasCustomRect>
            (m, "ImFontAtlasCustomRect", "See ImFontAtlas::AddCustomRectXXX functions.")
            .def_readwrite("width", &ImFontAtlasCustomRect::Width, "Input    // Desired rectangle dimension")
            .def_readwrite("height", &ImFontAtlasCustomRect::Height, "Input    // Desired rectangle dimension")
            .def_readwrite("x", &ImFontAtlasCustomRect::X, "Output   // Packed position in Atlas")
            .def_readwrite("y", &ImFontAtlasCustomRect::Y, "Output   // Packed position in Atlas")
            .def_readwrite("glyph_id", &ImFontAtlasCustomRect::GlyphID, "Input    // For custom font glyphs only (ID < 0x110000)")
            .def_readwrite("glyph_advance_x", &ImFontAtlasCustomRect::GlyphAdvanceX, "Input    // For custom font glyphs only: glyph xadvance")
            .def_readwrite("glyph_offset", &ImFontAtlasCustomRect::GlyphOffset, "Input    // For custom font glyphs only: glyph display offset")
            .def_readwrite("font", &ImFontAtlasCustomRect::Font, "Input    // For custom font glyphs only: target font")
            .def(py::init<>())
            .def("is_packed",
                 &ImFontAtlasCustomRect::IsPacked, "(private API)")
    ;


    py::enum_<ImFontAtlasFlags_>(m, "ImFontAtlasFlags_", py::arithmetic(), "Flags for ImFontAtlas build")
        .value("none", ImFontAtlasFlags_None, "")
        .value("no_power_of_two_height", ImFontAtlasFlags_NoPowerOfTwoHeight, "Don't round the height to next power of two")
        .value("no_mouse_cursors", ImFontAtlasFlags_NoMouseCursors, "Don't build software mouse cursors into the atlas (save a little texture memory)")
        .value("no_baked_lines", ImFontAtlasFlags_NoBakedLines, "Don't build thick line textures into the atlas (save a little texture memory, allow support for point/nearest filtering). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).");


    auto pyClassImFontAtlas =
        py::class_<ImFontAtlas>
            (m, "ImFontAtlas", " Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:\n  - One or more fonts.\n  - Custom graphics data needed to render the shapes needed by Dear ImGui.\n  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).\n It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.\n  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.\n  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.\n  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)\n  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.\n    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.\n Common pitfalls:\n - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the\n   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.\n - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.\n   You can set font_cfg->FontDataOwnedByAtlas=False to keep ownership of your data and it won't be freed,\n - Even though many functions are suffixed with \"TTF\", OTF data is supported just as well.\n - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!")
            .def(py::init<>())
            .def("add_font",
                 &ImFontAtlas::AddFont,
                 py::arg("font_cfg"),
                 pybind11::return_value_policy::reference)
            .def("add_font_default",
                 &ImFontAtlas::AddFontDefault,
                 py::arg("font_cfg") = py::none(),
                 pybind11::return_value_policy::reference)
            .def("clear_input_data",
                 &ImFontAtlas::ClearInputData, "Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.")
            .def("clear_tex_data",
                 &ImFontAtlas::ClearTexData, "Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.")
            .def("clear_fonts",
                 &ImFontAtlas::ClearFonts, "Clear output font data (glyphs storage, UV coordinates).")
            .def("clear",
                 &ImFontAtlas::Clear, "Clear all input and output.")
            .def("build",
                 &ImFontAtlas::Build, "Build pixels data. This is called automatically for you by the GetTexData*** functions.")
            .def("is_built",
                 &ImFontAtlas::IsBuilt, "(private API)\n\n Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...")
            .def("set_tex_id",
                 &ImFontAtlas::SetTexID,
                 py::arg("id_"),
                 "(private API)")
                // #ifdef IMGUI_BUNDLE_PYTHON_API
                //
            .def("add_font_from_file_ttf",
                 &ImFontAtlas::_AddFontFromFileTTF,
                 py::arg("filename"), py::arg("size_pixels"), py::arg("font_cfg") = py::none(), py::arg("glyph_ranges_as_int_list") = py::none(),
                 pybind11::return_value_policy::reference)
            .def("get_glyph_ranges_default",
                 &ImFontAtlas::_GetGlyphRangesDefault, "// Basic Latin, Extended Latin")
            .def("get_glyph_ranges_greek",
                 &ImFontAtlas::_GetGlyphRangesGreek, "// Default + Greek and Coptic")
            .def("get_glyph_ranges_korean",
                 &ImFontAtlas::_GetGlyphRangesKorean, "// Default + Korean characters")
            .def("get_glyph_ranges_japanese",
                 &ImFontAtlas::_GetGlyphRangesJapanese, "// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs")
            .def("get_glyph_ranges_chinese_full",
                 &ImFontAtlas::_GetGlyphRangesChineseFull, "// Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs")
            .def("get_glyph_ranges_chinese_simplified_common",
                 &ImFontAtlas::_GetGlyphRangesChineseSimplifiedCommon, "// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese")
            .def("get_glyph_ranges_cyrillic",
                 &ImFontAtlas::_GetGlyphRangesCyrillic, "// Default + about 400 Cyrillic characters")
            .def("get_glyph_ranges_thai",
                 &ImFontAtlas::_GetGlyphRangesThai, "// Default + Thai characters")
            .def("get_glyph_ranges_vietnamese",
                 &ImFontAtlas::_GetGlyphRangesVietnamese, "// Default + Vietnamese characters")
                // #endif
                //
            .def("add_custom_rect_regular",
                 &ImFontAtlas::AddCustomRectRegular, py::arg("width"), py::arg("height"))
            .def("add_custom_rect_font_glyph",
                 &ImFontAtlas::AddCustomRectFontGlyph, py::arg("font"), py::arg("id_"), py::arg("width"), py::arg("height"), py::arg("advance_x"), py::arg("offset") = ImVec2(0, 0))
            .def("get_custom_rect_by_index",
                 &ImFontAtlas::GetCustomRectByIndex,
                 py::arg("index"),
                 "(private API)",
                 pybind11::return_value_policy::reference)
            .def("calc_custom_rect_uv",
                 &ImFontAtlas::CalcCustomRectUV, py::arg("rect"), py::arg("out_uv_min"), py::arg("out_uv_max"))
            .def("get_mouse_cursor_tex_data",
                 &ImFontAtlas::GetMouseCursorTexData, py::arg("cursor"), py::arg("out_offset"), py::arg("out_size"), py::arg("out_uv_border"), py::arg("out_uv_fill"))
            .def_readwrite("flags", &ImFontAtlas::Flags, "Build flags (see ImFontAtlasFlags_)")
            .def_readwrite("tex_id", &ImFontAtlas::TexID, "User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.")
            .def_readwrite("tex_desired_width", &ImFontAtlas::TexDesiredWidth, "Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.")
            .def_readwrite("tex_glyph_padding", &ImFontAtlas::TexGlyphPadding, "Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = False).")
            .def_readwrite("locked", &ImFontAtlas::Locked, "Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.")
            .def_readwrite("user_data", &ImFontAtlas::UserData, "Store your own atlas related user-data (if e.g. you have multiple font atlas).")
            .def_readwrite("tex_ready", &ImFontAtlas::TexReady, "Set when texture was built matching current font input")
            .def_readwrite("tex_pixels_use_colors", &ImFontAtlas::TexPixelsUseColors, "Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.")
            .def_readwrite("tex_width", &ImFontAtlas::TexWidth, "Texture width calculated during Build().")
            .def_readwrite("tex_height", &ImFontAtlas::TexHeight, "Texture height calculated during Build().")
            .def_readwrite("tex_uv_scale", &ImFontAtlas::TexUvScale, "= (1.0/TexWidth, 1.0/TexHeight)")
            .def_readwrite("tex_uv_white_pixel", &ImFontAtlas::TexUvWhitePixel, "Texture coordinates to a white pixel")
            .def_readwrite("fonts", &ImFontAtlas::Fonts, "Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.")
            .def_readwrite("custom_rects", &ImFontAtlas::CustomRects, "Rectangles for packing custom texture data into the atlas.")
            .def_readwrite("config_data", &ImFontAtlas::ConfigData, "Configuration data")
            .def_readonly("font_builder_io", &ImFontAtlas::FontBuilderIO, "Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).")
            .def_readwrite("font_builder_flags", &ImFontAtlas::FontBuilderFlags, "Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.")
            .def_readwrite("pack_id_mouse_cursors", &ImFontAtlas::PackIdMouseCursors, "Custom texture rectangle ID for white pixel and mouse cursors")
            .def_readwrite("pack_id_lines", &ImFontAtlas::PackIdLines, "Custom texture rectangle ID for baked anti-aliased lines")
    ;


}
